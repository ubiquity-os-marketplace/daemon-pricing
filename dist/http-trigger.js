import{app as Ke}from"@azure/functions";import{azureHonoHandler as ze}from"@marplex/hono-azurefunc-adapter";import{createAppAuth as ue}from"@octokit/auth-app";import{Octokit as De}from"@octokit/rest";import{createPlugin as We}from"@ubiquity-os/plugin-sdk";import{env as He}from"hono/adapter";import{customOctokit as je}from"@ubiquity-os/plugin-sdk/octokit";import{LOG_LEVEL as xe}from"@ubiquity-os/ubiquity-os-logger";var j={name:"Assistive pricing",description:"Handles assistive pricing, and allows for users to modify labels.","ubiquity:listeners":["repository.created","issues.opened","issues.labeled","issues.unlabeled","label.edited","push"],skipBotEvents:!1,configuration:{default:{},type:"object",properties:{globalConfigUpdate:{description:"Updates all price labels across all tasks based on `baseRateMultiplier` changes within the config file.",type:"object",properties:{excludeRepos:{examples:["repo-name","no-owner-required"],description:"List of repositories to exclude from being updated",type:"array",items:{type:"string"}}},required:["excludeRepos"]},labels:{default:{},type:"object",properties:{time:{minItems:1,default:[{name:"Time: <15 Minutes",collaboratorOnly:!1},{name:"Time: <1 Hour",collaboratorOnly:!1},{name:"Time: <2 Hours",collaboratorOnly:!1},{name:"Time: <4 Hours",collaboratorOnly:!1},{name:"Time: <1 Day",collaboratorOnly:!1},{name:"Time: <1 Week",collaboratorOnly:!1}],type:"array",items:{type:"object",properties:{name:{examples:["Time: <2 Hours","Time: <1 Week"],description:"The display name of the label representing estimated task length",pattern:"^Time:\\s<?\\d+\\s\\S+$",type:"string"}},required:["name"]}},priority:{minItems:1,default:[{name:"Priority: 0 (Regression)",collaboratorOnly:!1},{name:"Priority: 1 (Normal)",collaboratorOnly:!1},{name:"Priority: 2 (Medium)",collaboratorOnly:!1},{name:"Priority: 3 (High)",collaboratorOnly:!1},{name:"Priority: 4 (Urgent)",collaboratorOnly:!1},{name:"Priority: 5 (Emergency)",collaboratorOnly:!1}],type:"array",items:{type:"object",properties:{name:{examples:["Priority: 1 (Normal)","Priority: 5 (Emergency)"],description:"The display name of the label representing task priority",type:"string"},collaboratorOnly:{default:!1,description:"Whether the task is only available for collaborators to be assigned",type:"boolean"}},required:["name"]}}}},autoLabelingTrigger:{default:"auto_price",description:"The label that triggers automatic pricing when added to an issue.",type:"string"},enablePartialAutoEstimation:{default:!1,description:"Whether to enable automatic time estimation when some of the parameters are given.",type:"boolean"},enableAutoTimeEstimation:{default:!1,description:"Whether to enable automatic time estimation for issues",type:"boolean"},basePriceMultiplier:{examples:[1.5],default:1,description:"The base price multiplier for all tasks",type:"number"},shouldFundContributorClosedIssue:{default:!1,description:"Whether to allow funding contributor closed issues",type:"boolean"}}},homepage_url:"https://ubiquity-os-daemon-pricing-main.ubiquity.workers.dev"};var C={default:"ededed",price:"1f883d"},x="No owner found in the repository!";async function A(e){let{payload:r,octokit:i}=e,t=r.repository.owner?.login;if(!t)throw e.logger.error(x);let n=await i.paginate(i.rest.issues.listLabelsForRepo,{owner:t,repo:r.repository.name,per_page:100});return e.logger.debug(`Fetching labels for repository ${r.repository.html_url}`,{owner:t,repo:r.repository.name,labels:n.map(o=>o.name)}),n.length>0?(await new Promise(o=>setTimeout(o,5e3)),n):[]}async function g(e,r,i="default",t){let n=e.payload,o=r.startsWith("Price: ")?C.price:C[i],a=n.repository.owner?.login;if(!a)throw e.logger.error(x);try{let s={owner:a,repo:n.repository.name,name:r,color:o,description:t};e.logger.debug("Trying to create label",{createLabelsOptions:s}),await e.octokit.rest.issues.createLabel(s)}catch(s){e.logger.error("Creating a label failed!",{err:s})}}async function T(e){let r=e.payload;if(!("issue"in r)||!r.issue)return;let i=r.issue.labels;if(!i)return;let t=i.filter(n=>n.name.toString().startsWith("Price: ")||n.name.toString().startsWith("Pricing: "));if(t.length)for(let n of t)try{await e.octokit.rest.issues.removeLabel({owner:r.repository.owner.login,repo:r.repository.name,issue_number:r.issue.number,name:n.name})}catch(o){if(o&&typeof o=="object"&&"status"in o&&o.status===404)e.logger.error(`Label [${n.name}] not found on issue ${r.issue.html_url}, ignoring.`,{err:o});else throw e.logger.error(`Removing label on issue ${r.issue.html_url} failed!`,{label:n,err:o})}}async function b(e,r){let i=e.payload;if(!(!("issue"in i)||!i.issue))try{await e.octokit.rest.issues.addLabels({owner:i.repository.owner.login,repo:i.repository.name,issue_number:i.issue.number,labels:[r]})}catch(t){throw e.logger.error("Adding a label to issue failed!",{err:t})}}async function k(e,r){let i=e.payload;if(!(!("issue"in i)||!i.issue))try{await e.octokit.rest.issues.removeLabel({owner:i.repository.owner.login,repo:i.repository.name,issue_number:i.issue.number,name:r})}catch(t){throw e.logger.error("Removing a label from an issue failed!",{err:t})}}import{Decimal as V}from"decimal.js";async function L(e,r,i,t){let n={"Content-Type":"application/json",Authorization:`Api-Key ${i}`},o=JSON.stringify({title:r,description:e}),a=await fetch(t,{method:"POST",headers:n,body:o});if(!a.ok)throw new Error(`Error: ${a.status} ${a.statusText}`);let s=await a.json();if(!s)throw new Error("No data returned from Baseten API");let p=s.estimated_time,l=s.priority;if(!p||!l)throw new Error("No time or priority returned from Baseten API");return{time:p,priority:l}}function v(e,r,i){let t=RegExp(/\d+/).exec(i)?.[0];if(!t)throw new Error("No priority value found");let n=new V(t).div(10);return new V(e).mul(1e3).mul(r*.125).mul(n).toDecimalPlaces(2)}function _(e){let r=parseFloat(e);if(isNaN(r))throw new Error("Invalid time estimate");if(r<1){let i=Math.round(r*60);return`Time: ${i} minute${i===1?"":"s"}`}else if(r<24){let i=Math.round(r);return`Time: ${i} hour${i===1?"":"s"}`}else if(r<24*7){let i=Math.round(r/24);return`Time: ${i} day${i===1?"":"s"}`}else{let i=Math.round(r/168);return`Time: ${i} week${i===1?"":"s"}`}}async function K(e){let{payload:r,logger:i,env:t,config:n}=e;if(!("issue"in r)||!r.issue){i.debug("No issue found in the payload");return}let o=r.issue,a=o.labels||[];if((!a||a.length===0)&&i.info("No labels found on the issue, skipping pricing labels update."),!o.body){i.info("No issue body found, skipping pricing labels update.");return}if(t.BASETEN_API_KEY===void 0||t.BASETEN_API_URL===void 0)throw i.error("BASETEN_API_KEY or BASETEN_API_URL is not set in the environment variables.");let s=await L(o.body,o.title,t.BASETEN_API_KEY,t.BASETEN_API_URL);if(!s){i.error("No priority time estimate found, skipping pricing labels update.");return}let{time:p,priority:l}=s;i.info(`Priority: ${l}, Time: ${p} hours`);let c=_(p);await g(e,c),await b(e,l),await b(e,c),i.info(`Added priority label: ${l} and time label: ${c} to the issue #${o.number}`);let u=`Price: ${v(n.basePriceMultiplier,parseFloat(p),l).toFixed(2)} USD`;i.info(`Calculated price label: ${u}`),await g(e,u),await b(e,u),i.info(`Added price label: ${u} to the issue #${o.number}`)}import{CONFIG_ORG_REPO as Ue}from"@ubiquity-os/plugin-sdk/constants";var O="chore: [skip ci] update labels configuration";async function z(e){let{octokit:r,payload:i,logger:t}=e,n=i.repository.owner?.login,o=i.repository.name,a=`heads/${i.repository.default_branch}`;if(!n)throw t.error("No owner was found in the repository, a commit / push action cannot be performed.",{payload:i});let p=(await r.rest.git.getRef({owner:n,repo:o,ref:a})).data.object.sha,c=(await r.rest.git.getCommit({owner:n,repo:o,commit_sha:p})).data.tree.sha,u=(await r.rest.git.createCommit({owner:n,repo:o,message:O,tree:c,parents:[p]})).data.sha,{data:P}=await r.rest.git.updateRef({owner:n,repo:o,ref:a,sha:u});t.info(`Pushed an empty commit to ${i.repository.html_url}`,{commitUrl:P.url})}async function be(e,r){let i=e.payload.repository.owner?.login;if(!i)throw e.logger.error("No owner found in the repository!");return(await e.octokit.rest.repos.getCollaboratorPermissionLevel({owner:i,repo:e.payload.repository.name,username:r})).data.permission==="admin"}async function ye(e,r){if(!e.payload.organization)throw e.logger.error("No organization found in payload!");try{await e.octokit.rest.orgs.checkMembershipForUser({org:e.payload.organization.login,username:r})}catch{return!1}let{data:i}=await e.octokit.rest.orgs.getMembershipForUser({org:e.payload.organization.login,username:r});return i.role==="billing_manager"}function he(e){let{payload:r}=e;return r.sender?.type==="Bot"}async function $(e,r){return r?await be(e,r)||he(e)?"admin":await ye(e,r)?"billing_manager":!1:!1}async function G(e){let r=e.payload.organization?.login;if(!r)throw e.logger.error("No organization found in payload!",{payload:e.payload});try{return(await e.octokit.rest.repos.listForOrg({org:r})).data.filter(t=>!t.archived&&!t.disabled&&!e.config.globalConfigUpdate?.excludeRepos.includes(t.name))}catch(i){throw e.logger.error("Listing org repos failed!",{err:i})}}async function Y(e,r,i){try{return await e.octokit.paginate(e.octokit.rest.issues.listForRepo,{owner:r,repo:i})}catch(t){throw e.logger.error("Listing repo issues failed!",{err:t})}}function E(e){return e.eventName==="issues.labeled"||e.eventName==="issues.unlabeled"}function y(e){return e.eventName==="push"}import{CONFIG_FULL_PATH as we,DEV_CONFIG_FULL_PATH as Pe}from"@ubiquity-os/plugin-sdk/constants";function q(e){let r=[];for(let i of e){if(i.modified?.length)for(let t of i.modified)r.push(t);if(i.added?.length)for(let t of i.added)r.push(t)}return r}var Le="0000000000000000000000000000000000000000",Ee=[Pe,we];async function J(e){if(!y(e))return e.logger.debug("Not a push event"),!1;let{logger:r,payload:i}=e;if(i.before===Le)return r.info("Skipping push events. A new branch was created"),!1;let t=q(i.commits);if(t&&t.length===0)return r.info("No files were changed in the commits, so no action is required."),!1;let n=!1;for(let o of Ee)if(t.includes(o)){r.info(`${o} was modified or added in the commits`),n=!0;break}return n}async function Q(e){if(!y(e))return e.logger.debug("Not a push event"),!1;let{logger:r,payload:{repository:i,head_commit:t}}=e,n=t?.id,o;if(!n)throw new Error("No commit sha found");let a=i.owner?.login;if(!a)throw r.error("No owner found in the repository");try{o=await e.octokit.rest.repos.getCommit({owner:a,repo:i.name,ref:n,mediaType:{format:"diff"}})}catch(P){r.debug("Commit sha error.",{err:P})}if(!o)throw new Error("No commit data found");let p=o.data.split(`
`),l=/\+\s*collaboratorOnly:\s*(\S+)/,c=/-\s*collaboratorOnly:\s*(\S+)/,m=Z(p,l),u=Z(p,c);return!u&&!m&&r.error("No label changes found in the diff"),!!u?.length||!!m?.length}function Z(e,r){let t=e?.find(n=>r.test(n))?.match(r);return t?t[1]:void 0}import{Decimal as U}from"decimal.js";function Ce(e){let r=e.map(a=>{let s=RegExp(/(\D*)(\d*\.?\d+)(\D*)/).exec(a.name);if(!s)throw new Error("Labels do not seem to contain any number value, please check your configuration.");return{prefix:s[1],number:s[2],suffix:s[3]}}),i=r.map(a=>a.prefix),t=r.map(a=>a.suffix),n=i.reduce((a,s)=>a===s?a:"",i[0]),o=t.reduce((a,s)=>a===s?a:"",t[0]);if(!n&&!o)throw new Error("No common prefixes or suffixes have been found for the label list, please check your configuration.");return`${n.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}(\\d*\\.?\\d+)${o.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}`}function Te(e){return e.map(r=>{let i=RegExp(/\d*\.?\d+/).exec(r.name);return i?parseInt(i[0],10):null})}function w(e){if(Te(e).some(t=>t===null))throw new Error("Some tags seem to not have any number value, please check your configuration.");let i=Ce(e);return new RegExp(i,"i")}function X(e){let r=w(e);if(!r)throw new Error(`Could not determine the label pattern. Tags: ${JSON.stringify(e)}`);function i(o){let a=r?.exec(o);return a?parseInt(a[1],10):-1}let t=i(e[0].name),n=i(e[1].name);return t<n?1:-1}function B(e,r,i,t){let n=t??e.config.basePriceMultiplier,o=new U(i).div(10);if(X(e.config.labels.priority)<0){let s=e.config.labels.priority.reduce((p,l)=>{let c=RegExp(/\d+/).exec(l.name);if(c!==null){let m=Number(c);if(m>p)return m}return p},0);o=new U(s-i).div(10)}return new U(n).mul(1e3).mul(r).mul(o).toDecimalPlaces(2).toString()}function ee(e,r,i){let t=e.logger,{labels:n}=e.config;if(!r||!i)throw t.error("Time or priority label is not defined");let o=n.time.find(s=>s.name===r.name);if(!o)throw t.error("Time label is not recognized");let a=n.priority.find(s=>s.name===i.name);if(!a)throw t.error("Priority label is not recognized");return Ae(e,o,a)}function Ae(e,r,i){let{logger:t}=e,n=h(e,r.name);if(n===null)throw t.error("Time value is not defined");let o=h(e,i.name);if(o===null)throw t.error("Priority value is not defined");return`Price: ${B(e,n,o)} USD`}function h(e,r){let i=r.match(/\d+/);if(!i?.length)return null;let t=parseInt(i[0]),n=w(e.config.labels.priority),o=w(e.config.labels.time);if(n.test(r))return t;if(o.test(r)){if(r.toLowerCase().includes("minute"))return t*.002;if(r.toLowerCase().includes("hour"))return t*.125;if(r.toLowerCase().includes("day"))return 1+(t-1)*.25;if(r.toLowerCase().includes("week"))return t+1;if(r.toLowerCase().includes("month"))return 5+(t-1)*8}return null}async function re(e,r){if(r.filter(t=>t.name.toString().startsWith("Price:")).length)throw await T(e),e.logger.warn("Pricing is disabled on parent issues, so the price labels have been cleared.");if(e.eventName==="issues.labeled")throw e.logger.warn("Pricing is not supported on parent issues, no price will be set.")}function S(e,r){return r.sort((i,t)=>(h(e,i.name)||0)-(h(e,t.name)||0))}function ie(e){return RegExp(/-\s+\[([ x])]\s+#\d+/).exec(e)}async function te(e){if(!E(e))return;let r=e.payload,i=e.logger,t=r.sender?.type==="Bot",n=r.label?.name||"";if(t&&n.includes("Price: "))return;let o=e.config,a=r.repository.owner?.login;if(!a){i.error("No owner found in the repository");return}let s=r.issue.labels;if(!s)return;if(r.issue.body&&ie(r.issue.body)){await re(e,s);return}let p=n.includes("Price: ");if(p&&r.sender?.type==="User"){let l=s.filter(u=>u.name.includes("Price: ")),c=S(e,l);if(c.shift())for(let u of c)await e.octokit.rest.issues.removeLabel({owner:a,repo:r.repository.name,issue_number:r.issue.number,name:u.name});return}p||await M(e,s,o)}async function ve(e,r,i){let t=e.logger;if(!E(e)){t.error("No issue found in the payload");return}let n=oe(r,i),o=ne(e,n),a=e.payload.issue.body||"",s=e.payload.issue.title,{BASETEN_API_KEY:p,BASETEN_API_URL:l}=e.env;if(!p||!l){t.error("Baseten API key or URL is not set in the environment variables.");return}let{time:c,priority:m}=await L(a,s,p,l);if(!c||!m){t.error("No time or priority returned from Baseten API");return}let u=_(c);o.priority&&!o.time?(await g(e,u,"default"),await b(e,u)):o.time&&!o.priority?await b(e,m):!o.time&&!o.priority&&(await g(e,u,"default"),await b(e,m),await b(e,u))}async function _e(e,r,i){let t=e.logger,n=oe(r,i),o=w(i.labels.time),a=w(i.labels.priority),s=r.map(m=>m.name),p=r.filter(m=>o.test(m.name)||a.test(m.name)).length>=2;if(!n.time.length||!n.priority.length){if(e.eventName==="issues.labeled"&&p){let m=t.error("No recognized labels were found to set the price of this task.",{repo:e.payload.repository.html_url,recognizedLabels:n});await e.commentHandler.postComment(e,m)}await T(e);return}let l=ne(e,n);if(!l.time||!l.priority)return;for(let m of n.time)m.name!==l.time.name&&await k(e,m.name);for(let m of n.priority)m.name!==l.priority.name&&await k(e,m.name);let c=ee(e,l.time,l.priority);c&&await Oe(e,{name:c,description:null},s)}async function M(e,r,i){let t=e.logger,n=i.autoLabelingTrigger;e.payload.sender?.type==="User"&&i.enablePartialAutoEstimation&&e.payload.label?.name===n?await ve(e,r,i):await _e(e,r,i)}function oe(e,r){function i(o,a){return(typeof o=="string"||typeof o=="object")&&a.some(s=>s===o.name)}let t=e.filter(o=>i(o,r.labels.time.map(a=>a.name))),n=e.filter(o=>i(o,r.labels.priority.map(a=>a.name)));return{time:t,priority:n}}function ne(e,r){let i=S(e,r.time).shift(),t=S(e,r.priority).shift();return{time:i,priority:t}}async function Oe(e,r,i){let{repository:t}=e.payload;t.name==="devpool-directory"&&(r.name=r.name.replace("Price: ","Pricing: ")),i.find(o=>o.includes(r.name))?await Se(e,r.name):((await A(e)).filter(a=>a.name.includes(r.name)).length===0&&await g(e,r.name,"price"),await ae(e,r.name))}async function Se(e,r){let i=e.logger,t=await Ie(e);t&&(t=t.filter(n=>"label"in n&&n.label.name.includes("Price")),t.length&&(t[t.length-1].actor?.type=="User"||await ae(e,r)))}async function ae(e,r){await T(e),await b(e,r)}async function Ie(e){let r=await Ne(e);return r?r.filter(i=>i.event==="labeled"):null}async function Ne(e){if(!("issue"in e.payload)||!e.payload.issue){e.logger.debug("Not an issue event");return}try{return await e.octokit.paginate(e.octokit.rest.issues.listEvents,{owner:e.payload.repository.owner.login,repo:e.payload.repository.name,issue_number:e.payload.issue.number,per_page:100})}catch(r){return e.logger.error("Failed to fetch lists of events",{err:r}),[]}}var Re="No owner found in the repository!";async function ke(e){let{config:r,logger:i}=e,t=[];for(let n of r.labels.time)for(let o of r.labels.priority){let a=h(e,n.name),s=h(e,o.name);if(a===null||s===null){i.info("Time or Priority label is not defined, skipping.",{timeLabel:n,priorityLabel:o});continue}let l=`Price: ${B(e,a,s,r.basePriceMultiplier)} USD`;t.some(c=>c.name===l)||t.push({name:l})}return i.debug("Generated price labels",{basePriceMultiplier:r.basePriceMultiplier,priceLabels:t.map(n=>n.name),timeLabels:r.labels.time.map(n=>n.name),priorityLabels:r.labels.priority.map(n=>n.name)}),{priceLabels:t,pricingLabels:[...t,...r.labels.time,...r.labels.priority]}}async function D(e){let{pricingLabels:r,priceLabels:i}=await ke(e),t=await A(e);return{incorrectPriceLabels:t.filter(o=>o.name.startsWith("Price: ")&&!i.some(a=>a.name===o.name)),allLabels:t,pricingLabels:r}}async function I(e){let{logger:r,config:i}=e,t=e.payload.repository.owner?.login;if(!t)throw r.error(Re);let{allLabels:n,pricingLabels:o,incorrectPriceLabels:a}=await D(e);await $e(e,n,i.autoLabelingTrigger);let s=n.filter(l=>l.name.startsWith("Price: ")&&l.color!==C.price);s.length>0&&(r.info("Incorrect color labels found, updating them",{incorrectColorPriceLabels:s.map(l=>l.name)}),await Promise.allSettled(s.map(l=>e.octokit.rest.issues.updateLabel({owner:t,repo:e.payload.repository.name,name:l.name,color:C.price}))),r.info("Updating incorrect color labels done"));let p=[...new Set(o.filter(l=>!n.map(c=>c.name).includes(l.name)).map(l=>l.name))];p.length>0?(await F(e,a),r.info(`Missing labels found in ${e.payload.repository.html_url}, creating them`,{missingLabels:p}),await Promise.allSettled(p.map(l=>g(e,l,"default"))),r.info("Creating missing labels done")):a.length>0&&await F(e,a)}async function $e(e,r,i){let{logger:t,config:n}=e;n.enablePartialAutoEstimation?r.some(a=>a.name===i)?t.info(`Auto-labeling trigger label "${i}" already exists.`):(t.info(`Auto-labeling trigger label "${i}" not found, creating it.`),await g(e,i,"default")):r.some(a=>a.name===i)&&await F(e,r.filter(a=>a.name===i))}async function F(e,r){let{logger:i}=e,t=e.payload.repository.owner?.login;if(!t)throw i.error("No owner found in the repository!");r.length>0&&(i.info(`Will attempt to remove incorrect price labels within ${e.payload.repository.html_url}`,{incorrectPriceLabels:r.map(n=>n.name)}),await Promise.allSettled(r.map(n=>e.octokit.rest.issues.deleteLabel({owner:t,repo:e.payload.repository.name,name:n.name})))),i.info("Incorrect price labels removal done")}async function Be(e){if(!y(e))return e.logger.debug("Not a push event"),!1;let{payload:r,logger:i}=e,t=r.sender?.login,n=r.pusher?.name,o=await $(e,n),a=await $(e,t);return o||i.error("Pusher is not an admin or billing manager",{login:n}),a||i.error("Sender is not an admin or billing manager",{login:t}),!!(o&&a)}async function Me(e){let{logger:r,config:{globalConfigUpdate:i}}=e,t=[],{repository:n}=e.payload;n.name===Ue?t.push(...(await G(e)).filter(o=>!i?.excludeRepos.includes(o.name))):t.push(e.payload.repository),r.info("Will send an empty commit to the following list of repositories",{repos:t.map(o=>o.html_url)});for(let o of t){let a={...e,payload:{repository:o}};try{await z(a)}catch(s){r.warn(`Could not push an empty commit to ${o.html_url}`,{err:s})}}}async function se(e){if(!y(e)){e.logger.debug("Not a push event");return}let{logger:r}=e;if(!await Be(e)){r.error("Changes should be pushed and triggered by an admin or billing manager.");return}if((await J(e)||await Q(e))&&y(e)){await Me(e);return}else if(e.payload.head_commit?.message!==O){r.info("The commit name does not match the label update commit message, won't update labels.",{url:e.payload.repository.html_url});return}let{incorrectPriceLabels:t,allLabels:n,pricingLabels:o}=await D(e),a=[...new Set(o.filter(m=>!n.map(u=>u.name).includes(m.name)).map(m=>m.name))];if(t.length<=0&&a.length<=0){r.info("No incorrect price label to delete and no labels are missing, skipping.",{url:e.payload.repository.html_url});return}let s=e.payload.repository;r.info(`Updating pricing labels in ${s.html_url}`,{incorrectPriceLabels:t,missingLabels:a});let p=s.owner?.login,l=s.name;if(!p)throw r.error("No owner was found in the payload.");await I(e);let c=await Y(e,p,l);for(let m of c){let u={...e,payload:{...e.payload,issue:m}};await M(u,m.labels,u.config)}}function N(){return process.env.NODE_ENV==="local"}function le(){return N()||!!process.env.GITHUB_ACTIONS}function me(){return N()||!process.env.GITHUB_ACTIONS}async function R(e){let{eventName:r,logger:i,config:t}=e;switch(r){case"issues.opened":case"repository.created":le()&&(await I(e),t.enableAutoTimeEstimation&&(i.info("Auto pricing enabled, running auto pricing handler."),await K(e)));break;case"issues.labeled":case"issues.unlabeled":i.info(`Event ${r} detected.`),E(e)&&me()?(i.info(`Event ${r} detected, running label change pricing handler.`),await te(e)):(i.info(`Event ${r} detected, but not running label change pricing handler due to environment.`),i.info(`isIssueLabelEvent: ${E(e)}`),i.info(`isWorkerOrLocalEnvironment: ${me()}`));break;case"push":le()&&await se(e);break;default:i.error(`Event ${r} is not supported`)}return{message:"OK"}}import{Type as d}from"@sinclair/typebox";import{LOG_LEVEL as Fe}from"@ubiquity-os/ubiquity-os-logger";var pe=d.Object({LOG_LEVEL:d.Optional(d.Enum(Fe)),KERNEL_PUBLIC_KEY:d.Optional(d.String()),ACTION_REF:d.Optional(d.String()),APP_ID:d.Optional(d.String()),APP_PRIVATE_KEY:d.Optional(d.String()),APP_INSTALLATION_ID:d.Optional(d.String()),BASETEN_API_KEY:d.Optional(d.String()),BASETEN_API_URL:d.Optional(d.String())});import{Type as f}from"@sinclair/typebox";var ce=f.Object({globalConfigUpdate:f.Optional(f.Object({excludeRepos:f.Array(f.String(),{examples:["repo-name","no-owner-required"],description:"List of repositories to exclude from being updated"})},{description:"Updates all price labels across all tasks based on `baseRateMultiplier` changes within the config file."})),labels:f.Object({time:f.Array(f.Object({name:f.String({examples:["Time: <2 Hours","Time: <1 Week"],description:"The display name of the label representing estimated task length",pattern:/^Time:\s<?\d+\s\S+$/i.source})}),{minItems:1,default:[{name:"Time: <15 Minutes",collaboratorOnly:!1},{name:"Time: <1 Hour",collaboratorOnly:!1},{name:"Time: <2 Hours",collaboratorOnly:!1},{name:"Time: <4 Hours",collaboratorOnly:!1},{name:"Time: <1 Day",collaboratorOnly:!1},{name:"Time: <1 Week",collaboratorOnly:!1}]}),priority:f.Array(f.Object({name:f.String({examples:["Priority: 1 (Normal)","Priority: 5 (Emergency)"],description:"The display name of the label representing task priority"}),collaboratorOnly:f.Boolean({default:!1,description:"Whether the task is only available for collaborators to be assigned"})}),{minItems:1,default:[{name:"Priority: 0 (Regression)",collaboratorOnly:!1},{name:"Priority: 1 (Normal)",collaboratorOnly:!1},{name:"Priority: 2 (Medium)",collaboratorOnly:!1},{name:"Priority: 3 (High)",collaboratorOnly:!1},{name:"Priority: 4 (Urgent)",collaboratorOnly:!1},{name:"Priority: 5 (Emergency)",collaboratorOnly:!1}]})},{default:{}}),autoLabelingTrigger:f.String({default:"auto_price",description:"The label that triggers automatic pricing when added to an issue."}),enablePartialAutoEstimation:f.Boolean({default:!1,description:"Whether to enable automatic time estimation when some of the parameters are given."}),enableAutoTimeEstimation:f.Boolean({default:!1,description:"Whether to enable automatic time estimation for issues"}),basePriceMultiplier:f.Number({examples:[1.5],default:1,description:"The base price multiplier for all tasks"}),shouldFundContributorClosedIssue:f.Boolean({default:!1,description:"Whether to allow funding contributor closed issues"})},{default:{}});async function Ve(e,r){let{payload:i,logger:t,env:n}=e;if(!i.repository.owner)throw t.fatal("Owner is missing from payload",{payload:i});if(!n.ACTION_REF)throw t.fatal("ACTION_REF is missing from the environment");let a=RegExp(/^([\w-]+)\/([\w.-]+)@([\w./-]+)$/).exec(n.ACTION_REF);if(!a)throw t.fatal("The ACTION_REF is not in the proper format (owner/repo@ref)");let[,s,p,l]=a;t.info(`Will try to dispatch a workflow at ${s}/${p}@${l}`);let c=new je({authStrategy:ue,auth:{appId:e.env.APP_ID,privateKey:e.env.APP_PRIVATE_KEY}}),m;if(!n.APP_ID||!n.APP_PRIVATE_KEY)t.debug("APP_ID or APP_PRIVATE_KEY are missing from the env, will use the default Octokit instance."),m=e.octokit;else{let u=await c.rest.apps.getRepoInstallation({owner:s,repo:p});m=new De({authStrategy:ue,auth:{appId:e.env.APP_ID,privateKey:e.env.APP_PRIVATE_KEY,installationId:u.data.id}})}await m.rest.actions.createWorkflowDispatch({owner:s,repo:p,inputs:r,ref:l,workflow_id:"compute.yml"})}var fe={async fetch(e,r,i){let t=e.clone(),n=We(async o=>{switch(o.eventName){case"issues.opened":case"repository.created":case"push":{if(N())return R(o);{let a=await t.json();return Ve(o,a)}}case"issues.labeled":case"issues.unlabeled":return R(o);default:return R(o)}},j,{envSchema:pe,postCommentOnError:!0,settingsSchema:ce,logLevel:r.LOG_LEVEL||xe.INFO,kernelPublicKey:r.KERNEL_PUBLIC_KEY,bypassSignatureVerification:r.NODE_ENV==="local"});return n.post("/time",async o=>{let a=He(o),{BASETEN_API_KEY:s,BASE_PRICE_MULTIPLIER:p,BASETEN_API_URL:l}=a;if(s){if(!l)return o.json({error:"BASETEN_API_URL is not set"},500)}else return o.json({error:"BASETEN_API_KEY is not set"},500);let c=await o.req.json(),{issue_description:m,issue_title:u}=c,P=await L(m,u,s,l);if(!P)return o.json({error:"No priority time estimate"},500);let{time:W,priority:H}=P,de=v(parseFloat(p),parseFloat(W),H);return o.json({time:W,priority:H,price:de.toString()})}),n.fetch(e,r,i)}};Ke.http("http-trigger",{methods:["GET","POST"],authLevel:"anonymous",route:"{*proxy}",handler:ze(fe.fetch)});
